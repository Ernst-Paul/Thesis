---
title: "Why the best prediction is the worst imputation"
subtitle: "*Comparison between Biases and Prediction Accuracy*"
author: "E P Swens"

output:
  html_notebook: 
    toc: yes
    toc_float: true
---


******

##### *My To Do List*
- coverage berekenen

******


### Simulation
The following code performs the simulation

#### Settings
```{r}
library(mice)
library(tidyr)
library(plyr)
library(dplyr)
library(purrr)
library(jtools)
library(mvtnorm)
require(ggplot2)

set.seed(123)

# data generation setting
n.sim = 10
n.rec = 1000
mean = c(0, 0, 0)
cor_X1_X2 = .1
cor_X1_X3 = .6
cor_X2_X3 = .8

# amputation setting
p = .8
pattern = matrix(c(1,1,0,1,0,1), ncol = 3, nrow = 2, byrow = TRUE)

# imputation setting
methods = c("mean", "norm.predict", "norm.nob", "norm.nob", "norm", "norm", "pmm", "pmm")
names = c("mean", "reg", "stoch.m1", "stoch.m5", "bayes.m1", "bayes.m5", "pmm.m1", "pmm.m5")
m = c(1, 1, 1, 5, 1, 5, 1, 5)
maxit = c(1, 1, 7, 7, 7, 7, 7, 7)
```

#### Data Generation
```{r}
simulate <- function(n){
   # generate data
   data <- rmvnorm(n = n, mean = mean, 
                   sigma = matrix(c(1, cor_X1_X2, cor_X1_X3, cor_X1_X2, 1, cor_X2_X3, 
                                    cor_X1_X3, cor_X2_X3, 1), nrow = 3, ncol = 3))
   
   # ampute data
   missing <- ampute(data, prop = p, patterns = pattern, mech = "MCAR")
   
   # impute data
   for(i in seq_along(methods)) {
      assign(paste0("imp.",names[i]), mice(missing$amp, method=methods[i], m=m[i], maxit=maxit[i], printFlag=F))
   }
   
   # return list with imputation results
   return(list(imp.mean = imp.mean, imp.reg = imp.reg, imp.stoch.m1 = imp.stoch.m1, 
               imp.stoch.m5 = imp.stoch.m5, imp.bayes.m1 = imp.bayes.m1, imp.bayes.m5 =
               imp.bayes.m5, imp.pmm.m1 = imp.pmm.m1, imp.pmm.m5 = imp.pmm.m5,
               data = data))}

result <- replicate(n.sim, simulate(n = n.rec), simplify = FALSE)
```

### Results 
#### Imputed Estimates
```{r}
statistics <- function(x) {
   # orginial data and imputed data
   data <- as.data.frame(x[[1]])
   imp <- x[[2]]
   mids <- complete(imp, action = "all")
   
   # multiple imputation analysis
   if (imp[["m"]] > 1) {
      fit <- with(imp, lm(V3 ~ V2 + V1))
      est <- pool(fit)
      sum.est <- summary(est, conf.int = TRUE)
      
      x1.beta <- est$pooled$estimate[3]
      x1.beta.se <- est$pooled$ubar[3] %>% sqrt()
      x1.lower <- sum.est[3,"2.5 %"]
      x1.upper <-  sum.est[3,"97.5 %"]
      
      x2.beta <- est$pooled$estimate[2]
      x2.beta.se <- est$pooled$ubar[2] %>% sqrt()
      x2.lower <- sum.est[2,"2.5 %"]
      x2.upper <-  sum.est[2,"97.5 %"]
      
      r.squared <- mean(est$glanced$r.squared) 
      res.var <- (mean(est$glanced$sigma))^2
   } 
   # single imputation analysis
   else {
      fit <- lm(V3 ~ V2 + V1, data = mids[[1]])
      x1.beta <- mids %>% map(~lm(V3~V2+V1,data = .x)) %>% map(coefficients) %>% map_df("V1") %>% t()
      x1.beta.se <- summary(fit)$coefficients[3,2]

      x2.beta <- mids %>% map(~lm(V3~V2+V1,data = .x)) %>% map(coefficients) %>% map_df("V2") %>% t()
      x2.beta.se <- summary(fit)$coefficients[2,2]
      r.squared <- summary(fit)$r.squared
      res.var <- mids %>% map(~lm(V3~V2+V1,data = .x)) %>% map(residuals) %>% map_df(var) %>% t()
      
      x1.lower <- summ(fit, confint = TRUE, digits = 4) %>% .$coeftable %>% .["V1", 2] 
      x1.upper <- summ(fit, confint = TRUE, digits = 4) %>% .$coeftable %>% .["V1", 3] 
      x2.lower <- summ(fit, confint = TRUE, digits = 4) %>% .$coeftable %>% .["V2", 2] 
      x2.upper <- summ(fit, confint = TRUE, digits = 4) %>% .$coeftable %>% .["V2", 3] 
   }
   # mean and variance 
   y.mean <- mids %>% map_df(~mean(.$V3)) %>% t() %>% mean()
   y.var <- mids %>% map_df(~var(.$V3)) %>% t() %>% mean()
   
   # correlations and co-variances
   cor.x1.y <- mids %>% map_df(~cor(.$V1,.$V3)) %>% t() %>% mean()
   cor.x2.y <- mids %>% map_df(~cor(.$V2,.$V3)) %>% t() %>% mean()
   cor.x1.x2 <- mids %>% map_df(~cor(.$V1,.$V2)) %>% t() %>% mean()
   cov.x1.y <- mids %>% map_df(~cov(.$V1,.$V3)) %>% t() %>% mean()
   cov.x2.y <- mids %>% map_df(~cov(.$V2,.$V3)) %>% t() %>% mean()
   cov.x1.x2 <- mids %>% map_df(~cov(.$V1,.$V2)) %>% t() %>% mean()
   
   # coverage
   x1.truth <- lm(V3 ~ V2 + V1, data = data) %>% coefficients %>% .["V1"]
   x2.truth <- lm(V3 ~ V2 + V1, data = data) %>% coefficients %>% .["V2"]
   x1.coverage <- x1.lower < x1.truth & x1.truth < x1.upper
   x2.coverage <- x2.lower < x2.truth & x2.truth < x2.upper
   
   # RMSE
   predict <- mids %>% map("V3") %>% unlist()
   actual <- data$V3 %>% rep(imp[["m"]])
   rmse <- mean(sqrt((actual - predict)^2))
   
   return(c(y.mean, y.var, x1.beta, x1.beta.se, x2.beta, x2.beta.se, r.squared, res.var, 
         cov.x1.y, cor.x1.y, cov.x2.y, cor.x2.y, cov.x1.x2, cor.x1.x2, rmse, x1.coverage,
         x2.coverage))
}

format <- c("y.mean" = 0, "y.var" = 0, "x1.beta" = 0, "x1.beta.se" = 0, "x2.beta" = 0, 
            "x2.beta.se" = 0, "r.squared" = 0, "res.var" = 0, "cov.x1.y" = 0, "cor.x1.y" = 0, 
            "cov.x2.y" = 0, "cor.x2.y" = 0, "cov.x1.x2" = 0, "cor.x1.x2" = 0, "rmse" = 0,
            "x1.coverage" = 0, "x2.coverage" = 0)
```

#### True Estimates
```{r}
true.estimates <- function(x){
   y.mean <- mean(x[,3])
   y.var <- var(x[,3])
   y.lm <- lm(x[,3] ~ x[,2] + x[,1])
   
   r.squared <- summary(y.lm)$r.squared
   res.var <- (y.lm) %>% .$residuals %>% var()
   x1.beta <- summary(y.lm) %>% .$coefficients %>% .[3,1]
   x2.beta <- summary(y.lm) %>% .$coefficients %>% .[2,1]
   x1.beta.se <- summary(y.lm) %>% .$coefficients %>% .[3,2]
   x2.beta.se <- summary(y.lm) %>% .$coefficients %>% .[2,2]
   
   cor.x1.y = cov(x[,1],x[,3])
   cor.x2.y = cov(x[,2],x[,3])
   cor.x1.x2 = cov(x[,1],x[,2])
   cov.x1.y = cov(x[,1],x[,3])
   cov.x2.y = cov(x[,2],x[,3])
   cov.x1.x2 = cov(x[,1],x[,2])
   rmse = 0
   x1.coverage = 1
   x2.coverage = 1 
   
   return(c(y.mean, y.var, x1.beta, x1.beta.se, x2.beta, x2.beta.se, r.squared, res.var, 
         cov.x1.y, cor.x1.y, cov.x2.y, cor.x2.y, cov.x1.x2, cor.x1.x2, rmse, x1.coverage,
         x2.coverage))
}

format <- c("y.mean" = 0, "y.var" = 0, "x1.beta" = 0, "x1.beta.se" = 0, "x2.beta" = 0, 
            "x2.beta.se" = 0, "r.squared" = 0, "res.var" = 0, "cov.x1.y" = 0, "cor.x1.y" = 0, 
            "cov.x2.y" = 0, "cor.x2.y" = 0, "cov.x1.x2" = 0, "cor.x1.x2" = 0, "rmse" = 0,
            "x1.coverage" = 0, "x2.coverage" = 0)
```

### Result Estimates
```{r include=FALSE}
# add the imputed estimates
estimates <- result %>% map("data") %>% vapply(., true.estimates, format) %>% t() %>% colMeans() %>% round(5)

# add the imputed estimates
for (name in names) {
   print(name)
   estimates <- rbind(estimates,
      result %>% map(`[`, c("data", paste0("imp.",name))) %>% 
         vapply(., statistics, format) %>% t() %>% colMeans() %>% round(5))
}

# add the method names
rownames(estimates) <- c("true", names)
```

```{r echo=FALSE}
results <- list(estimates, pattern, p)
cat("Percentage Missing in X2: ", results[[3]]/2, "\n")
cat("Percentage Missing in Y: ", results[[3]]/2, "\n\n")
cat("Missingness patterns:\n")
cat(results[[2]][1,], "\n")
cat("Estimates:\n")
as.data.frame(results[[1]])
```
```{r}
mids <- complete(result %>% map("imp.reg") %>% .[[1]], action = "all")
data <- result[1] %>% map("data") %>% .[[1]]
fit <- lm(data[,3] ~ data[,1] + data[,2])

# lower
summ(fit, confint = TRUE, digits = 4) %>% .$coeftable %>% .["data[, 1]", 2] 
# upper
summ(fit, confint = TRUE, digits = 4) %>% .$coeftable %>% .["data[, 1]", 3] 
```
```{r}
imp <- result %>% map("imp.stoch.m5") %>% .[[1]]
mids <- complete(imp, action = "all")
data <- result[1] %>% map("data") %>% .[[1]]
   

fit <- with(imp, lm(V3 ~ V2 + V1))
est <- pool(fit)
sum.est <- summary(est, conf.int = TRUE)
x1.beta <- est$pooled$estimate[3]
x1.beta.se <- est$pooled$ubar[3] %>% sqrt()
x2.beta <- est$pooled$estimate[2]
x2.beta.se <- est$pooled$ubar[2] %>% sqrt()
r.squared <- mean(est$glanced$r.squared) 
res.var <- (mean(est$glanced$sigma))^2
x1.lower <- sum.est[3,"2.5 %"]
x1.upper <- sum.est[3,"97.5 %"]
sum.est[2,"2.5 %"]
sum.est[2,"97.5 %"]
truth <- sum.est[2,"estimate"]


coverage = x1.lower < truth & truth < x1.upper
```

```{r}
data <- result[1] %>% map("data") %>% .[[1]] %>% as.data.frame()
lm(V3 ~ V2 + V1, data = data) %>% coefficients %>% .["V2"]
```





